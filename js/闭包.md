# 闭包
<<<<<<< HEAD
> **闭包:**是指有权访问另一个函数作用域中的变量的函数;(出自javascript高程)
=======
> **闭包**：是指有权访问另一个函数作用域中的变量的函数;(摘自:**javascript高程**)


## 创建一个闭包
```js
function funA(a) {
  return function (b) {
    if(a>b) {
      return a - b;
    } else {
      return a + b;
    }
  }
}
const computed = funA(10);

const result = computed(8); // 闭包
```
这就是一个闭包,简单来说闭包形成的原因是:
> 由于funA函数的**局部变量a**无法正常被**回收(销毁)**
---
讲述具体原因之前我们先看一段代码:
```js
  function sort(val1, val2) {
    if(val1 > val2) {
      return 1;
    } else if (val1 < val2) {
      return -1;
    } else {
      return 0;
    }
  }
  const result = sort(10, 11);
```
首先当一个函数被调用时会创建一个**执行环境及作用域链**，而后台的每个执行环境中都有一个表示变量的对象——**变量对象**，而全局环境中**变量对象**是始终存在的。
> 当我们创建sort()函数时，会创建一个预先包含全局对象的作用域链，这个作用域链被保存在sort()函数内部的[[Scope]]属性中。当我们调用sort()函数时，会先创建一个**执行环境**然通过复制函数的[[Scope]]属性中的对象构建**执行环境**的作用域链；然后，会有一个‘**活动对象**（arguments、val1、val2）被创建并且被推入**执行环境**作用域链的前端。对于这个例子而言sort()函数的执行环境有两个变量对象分别是：**本地活动对象和全局变量对象**。而sort()函数的作用域链本质上是一个指针指向**全局变量对象**的指针列表，而不会实际包含**全局变量对象**;**无论什么时候再函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。正常来说当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域**。但是，闭包的情况又有所不同。

#### 回到第一个例子:
```js
function funA(a) {
  return function (b) {
    if(a>b) {
      return a - b;
    } else {
      return a + b;
    }
  }
}
const computed = funA(10);

let result = computed(8);

result = null; // 解除对匿名函数的引用(以便释放内存)
```
> 在funA内部的匿名函数会将外部的**活动对象**添加到它自己的作用域链中，因此在匿名函数的作用域链中，实际上已经包含了外部函数funA()的**活动变量**。当匿名函数从funA()函数返回后，它的作用域链包含了**活动对象**和**全局变量对象**。这导致了当funA()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链中仍在**引用**这个**活动对象**，导致funA()函数的**活动对象**仍然留在内存中，直至匿名函数被销毁。
>>>>>>> 300a21e74cff80465b724f1b0a90017bc8a79c98
